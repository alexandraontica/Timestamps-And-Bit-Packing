// Onțică Alexandra-Elena, 311CB

Task 1:
Prin operatiile % elimin pentru fiecare variabila in parte unitatile de timp mai mari decat aceasta.
Mai exact, pentru secunde imi ramane un numar din intervalul [0, 59]; elimin, asadar, minutele, orele etc. din total.
Pentru minute, imi ramane un numar de secunde din intervalul [0, 3599]; elimin , deci, orele, zilele etc. din total. Rezultatul il 
impart la numarul de secunde dintr-un minut pentru a calcula cate minute am.
La fel, pentru numarul de ore elimin zilele din total si impart la numarul de secunde dintr-o ora.

Taskurile 2 si 3:
Am parcurs "din zi in zi" intervalul de timp de la 1.1.1970 pana la momentul indicat de timestamp. Odata cu trecerea fiecarei zile am 
modificat data, verificand daca se ajunge la finalul unei luni sau a anului curent.

Task 4:
Am salvat in variabila result data si ora in UTC (folosindu-ma de functiile de la taskurile 3 si 1) si fusul orar in care trebuie sa
convertesc. Am tratat cazurile in care se trece la ziua urmatoare/precedenta separat, luand in considerare si cazurile in care se 
trece si la alta luna/alt an, modificand apoi si ora (+/- nr. ore diferenta fata de UTC, +/- 24 de ore dupa caz la trecerea in alta
zi).

Task 5:
Am adaugat la timestamp numarul de secude si echivalentul in secunde al numarului de minute, ore si zile complete. Apoi am adaugat
echivalentul in secunde al numarului de zile din lunile complete (tinand cont si de tipul anului - bisect sau nu). Pentru ani am
calculat cati ani bisecti au fost din 1970 pana la anul datei primite ca parametru. Am adaugat apoi la timestamp echivalentul in
secunde al anilor bisecti completi si al anilor "nebisecti" completi.

Task 6:
Mi-am creat un vector de siruri de caractere cu toate lunile anului ca sa-mi fie mai usor sa afisez numele lunii, apoi am facut 
afisarea in formatul cerut.

Task 7:
Pentru a extrage ziua, luna si anul din fiecare data citita in formatul dat m-am folosit de niste masti care aveau bitii de 1 pe 
pozitiile pe care in numar/data se afla ce cautam (ziua/luna/anul). Am salvat datele intr-un vector de tip TDate pe care l-am sortat si 
afisat.

Task 8:

unsigned int parte_din_data = 0, nr_biti_parte_din_data = 0, mask_parte_din_data = 1;

        for (i = 0; i < inturi_necesare; i++) {
            unsigned int biti_ramasi_neprelucrati = BITI_UNSIGNED_INT, biti_prelucrati = 0;

            while (biti_ramasi_neprelucrati >= BITI_DATA) {
                unsigned int biti_ramasi_pt_zile = 0;
                if (nr_biti_parte_din_data <= 5) {
                    biti_ramasi_pt_zile = 0;
                }

                unsigned int parte_din_data_zi = 
                unsigned int mask_zi = (BINAR_11111 - mask_parte_din_data) << (biti_prelucrati - biti_ramasi_pt);  // bitii de 1 sunt pe poz coresp zilei
                unsigned int zi = (inturi[i] & mask_zi) >> biti_prelucrati;  // raman doar bitii ce contin ziua
                data[j].day = (unsigned char)zi;

                unsigned int mask_luna = BINAR_1111;
                mask_luna <<= (BITI_ZI + biti_prelucrati);  // ajung cu bitii de 1 pe poz coresp lunii
                unsigned int luna = (inturi[i] & mask_luna) >> (BITI_ZI + biti_prelucrati);  // bitii ce contin luna
                data[j].month = (unsigned char)luna;

                unsigned int mask_an = BINAR_111111;
                mask_an <<= (BITI_LUNA + BITI_ZI + biti_prelucrati);  // ajung cu bitii de 1 pe poz coresp anului
                data[j].year = START_YEAR + ((inturi[i] & mask_an) >> (BITI_LUNA + BITI_ZI + biti_prelucrati));
                
                j++;
                biti_ramasi_neprelucrati -= BITI_DATA;
                biti_prelucrati += BITI_DATA;
                nr_biti_parte_din_data = 0;
                mask_parte_din_data = 1
            }

            if (biti_ramasi_neprelucrati > 0) {
                parte_din_data = inturi[i] >> biti_prelucrati;
                nr_biti_parte_din_data = biti_ramasi_neprelucrati;

                unsigned int putere_2 = 1;
                for (k = 1; k <= biti_ramasi_neprelucrati; k++) {
                    putere_2 *= 2;
                    mask_parte_din_data += putere_2;
                }
            }
        }
